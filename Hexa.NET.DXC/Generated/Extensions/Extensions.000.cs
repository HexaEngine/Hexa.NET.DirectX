// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using HexaGen.Runtime.COM;

namespace Hexa.NET.DXC
{
	public static unsafe partial class Extensions
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcIncludeHandler> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcIncludeHandler> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcIncludeHandler> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcIncludeHandler> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcIncludeHandler> comObj) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcIncludeHandler> comObj) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, char* pFilename, IDxcBlob** ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, pFilename, ppIncludeSource);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, ReadOnlySpan<char> pFilename, IDxcBlob** ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			fixed (char* ppFilename = pFilename)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, (char*)ppFilename, ppIncludeSource);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, string pFilename, IDxcBlob** ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, pStr0, ppIncludeSource);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, char* pFilename, ref IDxcBlob* ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			fixed (IDxcBlob** pppIncludeSource = &ppIncludeSource)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, pFilename, (IDxcBlob**)pppIncludeSource);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, char* pFilename, out ComPtr<IDxcBlob> ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			ppIncludeSource = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, pFilename, (IDxcBlob**)ppIncludeSource.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, ReadOnlySpan<char> pFilename, ref IDxcBlob* ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			fixed (char* ppFilename = pFilename)
			{
				fixed (IDxcBlob** pppIncludeSource = &ppIncludeSource)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, (char*)ppFilename, (IDxcBlob**)pppIncludeSource);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadSource(this ComPtr<IDxcIncludeHandler> comObj, string pFilename, ref IDxcBlob* ppIncludeSource) 
		{
			IDxcIncludeHandler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (IDxcBlob** pppIncludeSource = &ppIncludeSource)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcIncludeHandler*, char*, IDxcBlob**, HResult>)(handle->LpVtbl[3]))(handle, pStr0, (IDxcBlob**)pppIncludeSource);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlob> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcBlob* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlob> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcBlob* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlob> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlob* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlob> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlob* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcBlob> comObj) 
		{
			IDxcBlob* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcBlob> comObj) 
		{
			IDxcBlob* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetBufferPointer(this ComPtr<IDxcBlob> comObj) 
		{
			IDxcBlob* handle = comObj.Handle;
			void* ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, void*>)(handle->LpVtbl[3]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetBufferSize(this ComPtr<IDxcBlob> comObj) 
		{
			IDxcBlob* handle = comObj.Handle;
			nuint ret = ((delegate* unmanaged[Stdcall]<IDxcBlob*, nuint>)(handle->LpVtbl[4]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlobEncoding> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlobEncoding> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlobEncoding> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlobEncoding> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcBlobEncoding> comObj) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcBlobEncoding> comObj) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetBufferPointer(this ComPtr<IDxcBlobEncoding> comObj) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			void* ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, void*>)(handle->LpVtbl[3]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetBufferSize(this ComPtr<IDxcBlobEncoding> comObj) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			nuint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, nuint>)(handle->LpVtbl[4]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobEncoding> comObj, Bool32* pKnown, uint* pCodePage) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, pKnown, pCodePage);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobEncoding> comObj, ref Bool32 pKnown, uint* pCodePage) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			fixed (Bool32* ppKnown = &pKnown)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, (Bool32*)ppKnown, pCodePage);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobEncoding> comObj, Bool32* pKnown, ref uint pCodePage) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			fixed (uint* ppCodePage = &pCodePage)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, pKnown, (uint*)ppCodePage);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobEncoding> comObj, ref Bool32 pKnown, ref uint pCodePage) 
		{
			IDxcBlobEncoding* handle = comObj.Handle;
			fixed (Bool32* ppKnown = &pKnown)
			{
				fixed (uint* ppCodePage = &pCodePage)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobEncoding*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, (Bool32*)ppKnown, (uint*)ppCodePage);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlobUtf16> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlobUtf16> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlobUtf16> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlobUtf16> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetBufferPointer(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			void* ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, void*>)(handle->LpVtbl[3]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetBufferSize(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			nuint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, nuint>)(handle->LpVtbl[4]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf16> comObj, Bool32* pKnown, uint* pCodePage) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, pKnown, pCodePage);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf16> comObj, ref Bool32 pKnown, uint* pCodePage) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			fixed (Bool32* ppKnown = &pKnown)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, (Bool32*)ppKnown, pCodePage);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf16> comObj, Bool32* pKnown, ref uint pCodePage) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			fixed (uint* ppCodePage = &pCodePage)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, pKnown, (uint*)ppCodePage);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf16> comObj, ref Bool32 pKnown, ref uint pCodePage) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			fixed (Bool32* ppKnown = &pKnown)
			{
				fixed (uint* ppCodePage = &pCodePage)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, (Bool32*)ppKnown, (uint*)ppCodePage);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static char* GetStringPointer(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			char* ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, char*>)(handle->LpVtbl[6]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetStringPointerS(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			string ret = Utils.DecodeStringUTF16(((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, char*>)(handle->LpVtbl[6]))(handle));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetStringLength(this ComPtr<IDxcBlobUtf16> comObj) 
		{
			IDxcBlobUtf16* handle = comObj.Handle;
			nuint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf16*, nuint>)(handle->LpVtbl[7]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlobUtf8> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcBlobUtf8> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlobUtf8> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcBlobUtf8> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetBufferPointer(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			void* ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, void*>)(handle->LpVtbl[3]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetBufferSize(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			nuint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, nuint>)(handle->LpVtbl[4]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf8> comObj, Bool32* pKnown, uint* pCodePage) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, pKnown, pCodePage);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf8> comObj, ref Bool32 pKnown, uint* pCodePage) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			fixed (Bool32* ppKnown = &pKnown)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, (Bool32*)ppKnown, pCodePage);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf8> comObj, Bool32* pKnown, ref uint pCodePage) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			fixed (uint* ppCodePage = &pCodePage)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, pKnown, (uint*)ppCodePage);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetEncoding(this ComPtr<IDxcBlobUtf8> comObj, ref Bool32 pKnown, ref uint pCodePage) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			fixed (Bool32* ppKnown = &pKnown)
			{
				fixed (uint* ppCodePage = &pCodePage)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, Bool32*, uint*, HResult>)(handle->LpVtbl[5]))(handle, (Bool32*)ppKnown, (uint*)ppCodePage);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetStringPointer(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			byte* ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, byte*>)(handle->LpVtbl[6]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetStringPointerS(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			string ret = Utils.DecodeStringUTF8(((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, byte*>)(handle->LpVtbl[6]))(handle));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetStringLength(this ComPtr<IDxcBlobUtf8> comObj) 
		{
			IDxcBlobUtf8* handle = comObj.Handle;
			nuint ret = ((delegate* unmanaged[Stdcall]<IDxcBlobUtf8*, nuint>)(handle->LpVtbl[7]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcCompilerArgs> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcCompilerArgs> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcCompilerArgs> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcCompilerArgs> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcCompilerArgs> comObj) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcCompilerArgs> comObj) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// Pass GetArguments() and GetCount() to Compile<br/>
		/// </summary>
		public static char** GetArguments(this ComPtr<IDxcCompilerArgs> comObj) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			char** ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, char**>)(handle->LpVtbl[3]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCount(this ComPtr<IDxcCompilerArgs> comObj) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, uint>)(handle->LpVtbl[4]))(handle);
			return ret;
		}

		/// <summary>
		/// Add additional arguments or defines here, if desired.<br/>
		/// </summary>
		public static HResult AddArguments(this ComPtr<IDxcCompilerArgs> comObj, char** pArguments, uint argCount) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, char**, uint, HResult>)(handle->LpVtbl[5]))(handle, pArguments, argCount);
			return ret;
		}

		/// <summary>
		/// Add additional arguments or defines here, if desired.<br/>
		/// </summary>
		public static HResult AddArguments(this ComPtr<IDxcCompilerArgs> comObj, ref char* pArguments, uint argCount) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, char**, uint, HResult>)(handle->LpVtbl[5]))(handle, (char**)ppArguments, argCount);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult AddArgumentsUTF8(this ComPtr<IDxcCompilerArgs> comObj, byte** pArguments, uint argCount) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, byte**, uint, HResult>)(handle->LpVtbl[6]))(handle, pArguments, argCount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult AddArgumentsUTF8(this ComPtr<IDxcCompilerArgs> comObj, ref byte* pArguments, uint argCount) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			fixed (byte** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, byte**, uint, HResult>)(handle->LpVtbl[6]))(handle, (byte**)ppArguments, argCount);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult AddDefines(this ComPtr<IDxcCompilerArgs> comObj, Define* pDefines, uint defineCount) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, Define*, uint, HResult>)(handle->LpVtbl[7]))(handle, pDefines, defineCount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult AddDefines(this ComPtr<IDxcCompilerArgs> comObj, ref Define pDefines, uint defineCount) 
		{
			IDxcCompilerArgs* handle = comObj.Handle;
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompilerArgs*, Define*, uint, HResult>)(handle->LpVtbl[7]))(handle, (Define*)ppDefines, defineCount);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcLibrary> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcLibrary> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcLibrary> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcLibrary* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcLibrary> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcLibrary> comObj) 
		{
			IDxcLibrary* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcLibrary> comObj) 
		{
			IDxcLibrary* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult SetMalloc(this ComPtr<IDxcLibrary> comObj, IMalloc* pMalloc) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IMalloc*, HResult>)(handle->LpVtbl[3]))(handle, pMalloc);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult SetMalloc(this ComPtr<IDxcLibrary> comObj, ref IMalloc pMalloc) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IMalloc* ppMalloc = &pMalloc)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IMalloc*, HResult>)(handle->LpVtbl[3]))(handle, (IMalloc*)ppMalloc);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult SetMalloc(this ComPtr<IDxcLibrary> comObj, ComPtr<IMalloc> pMalloc) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IMalloc*, HResult>)(handle->LpVtbl[3]))(handle, (IMalloc*)pMalloc.Handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, uint offset, uint length, IDxcBlob** ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, pBlob, offset, length, ppResult);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, uint offset, uint length, IDxcBlob** ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, (IDxcBlob*)ppBlob, offset, length, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, uint offset, uint length, IDxcBlob** ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, (IDxcBlob*)pBlob.Handle, offset, length, ppResult);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, uint offset, uint length, ref IDxcBlob* ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob** pppResult = &ppResult)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, pBlob, offset, length, (IDxcBlob**)pppResult);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, uint offset, uint length, out ComPtr<IDxcBlob> ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			ppResult = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, pBlob, offset, length, (IDxcBlob**)ppResult.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, uint offset, uint length, ref IDxcBlob* ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				fixed (IDxcBlob** pppResult = &ppResult)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, (IDxcBlob*)ppBlob, offset, length, (IDxcBlob**)pppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromBlob(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, uint offset, uint length, out ComPtr<IDxcBlob> ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			ppResult = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, uint, uint, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, (IDxcBlob*)pBlob.Handle, offset, length, (IDxcBlob**)ppResult.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, char* pFileName, uint* codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pFileName, codePage, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, ReadOnlySpan<char> pFileName, uint* codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (char* ppFileName = pFileName)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, (char*)ppFileName, codePage, pBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, string pFileName, uint* codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pStr0, codePage, pBlobEncoding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, char* pFileName, ref uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (uint* pcodePage = &codePage)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pFileName, (uint*)pcodePage, pBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, ReadOnlySpan<char> pFileName, ref uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (char* ppFileName = pFileName)
			{
				fixed (uint* pcodePage = &codePage)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, (char*)ppFileName, (uint*)pcodePage, pBlobEncoding);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, string pFileName, ref uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (uint* pcodePage = &codePage)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pStr0, (uint*)pcodePage, pBlobEncoding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, char* pFileName, uint* codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pFileName, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, char* pFileName, uint* codePage, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pFileName, codePage, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, ReadOnlySpan<char> pFileName, uint* codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (char* ppFileName = pFileName)
			{
				fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, (char*)ppFileName, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, string pFileName, uint* codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pStr0, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, char* pFileName, ref uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (uint* pcodePage = &codePage)
			{
				fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pFileName, (uint*)pcodePage, (IDxcBlobEncoding**)ppBlobEncoding);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, char* pFileName, ref uint codePage, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (uint* pcodePage = &codePage)
			{
				pBlobEncoding = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pFileName, (uint*)pcodePage, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, ReadOnlySpan<char> pFileName, ref uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (char* ppFileName = pFileName)
			{
				fixed (uint* pcodePage = &codePage)
				{
					fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, (char*)ppFileName, (uint*)pcodePage, (IDxcBlobEncoding**)ppBlobEncoding);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobFromFile(this ComPtr<IDxcLibrary> comObj, string pFileName, ref uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (uint* pcodePage = &codePage)
			{
				fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, char*, uint*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, pStr0, (uint*)pcodePage, (IDxcBlobEncoding**)ppBlobEncoding);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingFromPinned(this ComPtr<IDxcLibrary> comObj, void* pText, uint size, uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[6]))(handle, pText, size, codePage, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingFromPinned(this ComPtr<IDxcLibrary> comObj, void* pText, uint size, uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[6]))(handle, pText, size, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingFromPinned(this ComPtr<IDxcLibrary> comObj, void* pText, uint size, uint codePage, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[6]))(handle, pText, size, codePage, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnHeapCopy(this ComPtr<IDxcLibrary> comObj, void* pText, uint size, uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[7]))(handle, pText, size, codePage, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnHeapCopy(this ComPtr<IDxcLibrary> comObj, void* pText, uint size, uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[7]))(handle, pText, size, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnHeapCopy(this ComPtr<IDxcLibrary> comObj, void* pText, uint size, uint codePage, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[7]))(handle, pText, size, codePage, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, IMalloc* pIMalloc, uint size, uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, pIMalloc, size, codePage, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, ref IMalloc pIMalloc, uint size, uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IMalloc* ppIMalloc = &pIMalloc)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, (IMalloc*)ppIMalloc, size, codePage, pBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, ComPtr<IMalloc> pIMalloc, uint size, uint codePage, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, (IMalloc*)pIMalloc.Handle, size, codePage, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, IMalloc* pIMalloc, uint size, uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, pIMalloc, size, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, IMalloc* pIMalloc, uint size, uint codePage, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, pIMalloc, size, codePage, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, ref IMalloc pIMalloc, uint size, uint codePage, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IMalloc* ppIMalloc = &pIMalloc)
			{
				fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, (IMalloc*)ppIMalloc, size, codePage, (IDxcBlobEncoding**)ppBlobEncoding);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateBlobWithEncodingOnMalloc(this ComPtr<IDxcLibrary> comObj, void* pText, ComPtr<IMalloc> pIMalloc, uint size, uint codePage, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, void*, IMalloc*, uint, uint, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[8]))(handle, pText, (IMalloc*)pIMalloc.Handle, size, codePage, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateIncludeHandler(this ComPtr<IDxcLibrary> comObj, IDxcIncludeHandler** ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcIncludeHandler**, HResult>)(handle->LpVtbl[9]))(handle, ppResult);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateIncludeHandler(this ComPtr<IDxcLibrary> comObj, ref IDxcIncludeHandler* ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcIncludeHandler** pppResult = &ppResult)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcIncludeHandler**, HResult>)(handle->LpVtbl[9]))(handle, (IDxcIncludeHandler**)pppResult);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateIncludeHandler(this ComPtr<IDxcLibrary> comObj, out ComPtr<IDxcIncludeHandler> ppResult) 
		{
			IDxcLibrary* handle = comObj.Handle;
			ppResult = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcIncludeHandler**, HResult>)(handle->LpVtbl[9]))(handle, (IDxcIncludeHandler**)ppResult.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, IStream** ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, pBlob, ppStream);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, IStream** ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, (IDxcBlob*)ppBlob, ppStream);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, IStream** ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, (IDxcBlob*)pBlob.Handle, ppStream);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, ref IStream* ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IStream** pppStream = &ppStream)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, pBlob, (IStream**)pppStream);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, out ComPtr<IStream> ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			ppStream = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, pBlob, (IStream**)ppStream.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, ref IStream* ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				fixed (IStream** pppStream = &ppStream)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, (IDxcBlob*)ppBlob, (IStream**)pppStream);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateStreamFromBlobReadOnly(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, out ComPtr<IStream> ppStream) 
		{
			IDxcLibrary* handle = comObj.Handle;
			ppStream = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IStream**, HResult>)(handle->LpVtbl[10]))(handle, (IDxcBlob*)pBlob.Handle, (IStream**)ppStream.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, pBlob, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, (IDxcBlob*)ppBlob, pBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, (IDxcBlob*)pBlob.Handle, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, pBlob, (IDxcBlobEncoding**)ppBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, pBlob, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, (IDxcBlob*)ppBlob, (IDxcBlobEncoding**)ppBlobEncoding);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf8(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[11]))(handle, (IDxcBlob*)pBlob.Handle, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, pBlob, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, (IDxcBlob*)ppBlob, pBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, IDxcBlobEncoding** pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, (IDxcBlob*)pBlob.Handle, pBlobEncoding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, pBlob, (IDxcBlobEncoding**)ppBlobEncoding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, IDxcBlob* pBlob, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, pBlob, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, ref IDxcBlob pBlob, ref IDxcBlobEncoding* pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			fixed (IDxcBlob* ppBlob = &pBlob)
			{
				fixed (IDxcBlobEncoding** ppBlobEncoding = &pBlobEncoding)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, (IDxcBlob*)ppBlob, (IDxcBlobEncoding**)ppBlobEncoding);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobAsUtf16(this ComPtr<IDxcLibrary> comObj, ComPtr<IDxcBlob> pBlob, out ComPtr<IDxcBlobEncoding> pBlobEncoding) 
		{
			IDxcLibrary* handle = comObj.Handle;
			pBlobEncoding = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcLibrary*, IDxcBlob*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[12]))(handle, (IDxcBlob*)pBlob.Handle, (IDxcBlobEncoding**)pBlobEncoding.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcOperationResult> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcOperationResult> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcOperationResult> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcOperationResult* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcOperationResult> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcOperationResult* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcOperationResult> comObj) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcOperationResult> comObj) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetStatus(this ComPtr<IDxcOperationResult> comObj, HResult* pStatus) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, HResult*, HResult>)(handle->LpVtbl[3]))(handle, pStatus);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetStatus(this ComPtr<IDxcOperationResult> comObj, ref HResult pStatus) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			fixed (HResult* ppStatus = &pStatus)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, HResult*, HResult>)(handle->LpVtbl[3]))(handle, (HResult*)ppStatus);
				return ret;
			}
		}

		/// <summary>
		/// GetResult returns the main result of the operation.<br/>
		/// This corresponds to:<br/>
		/// DXC_OUT_OBJECT - Compile() with shader or library target<br/>
		/// DXC_OUT_DISASSEMBLY - Disassemble()<br/>
		/// DXC_OUT_HLSL - Compile() with -P<br/>
		/// DXC_OUT_ROOT_SIGNATURE - Compile() with rootsig_* target<br/>
		/// </summary>
		public static HResult GetResult(this ComPtr<IDxcOperationResult> comObj, IDxcBlob** ppResult) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, ppResult);
			return ret;
		}

		/// <summary>
		/// GetResult returns the main result of the operation.<br/>
		/// This corresponds to:<br/>
		/// DXC_OUT_OBJECT - Compile() with shader or library target<br/>
		/// DXC_OUT_DISASSEMBLY - Disassemble()<br/>
		/// DXC_OUT_HLSL - Compile() with -P<br/>
		/// DXC_OUT_ROOT_SIGNATURE - Compile() with rootsig_* target<br/>
		/// </summary>
		public static HResult GetResult(this ComPtr<IDxcOperationResult> comObj, ref IDxcBlob* ppResult) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			fixed (IDxcBlob** pppResult = &ppResult)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, (IDxcBlob**)pppResult);
				return ret;
			}
		}

		/// <summary>
		/// GetResult returns the main result of the operation.<br/>
		/// This corresponds to:<br/>
		/// DXC_OUT_OBJECT - Compile() with shader or library target<br/>
		/// DXC_OUT_DISASSEMBLY - Disassemble()<br/>
		/// DXC_OUT_HLSL - Compile() with -P<br/>
		/// DXC_OUT_ROOT_SIGNATURE - Compile() with rootsig_* target<br/>
		/// </summary>
		public static HResult GetResult(this ComPtr<IDxcOperationResult> comObj, out ComPtr<IDxcBlob> ppResult) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			ppResult = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, IDxcBlob**, HResult>)(handle->LpVtbl[4]))(handle, (IDxcBlob**)ppResult.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// GetErrorBuffer Corresponds to DXC_OUT_ERRORS.<br/>
		/// </summary>
		public static HResult GetErrorBuffer(this ComPtr<IDxcOperationResult> comObj, IDxcBlobEncoding** ppErrors) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, ppErrors);
			return ret;
		}

		/// <summary>
		/// GetErrorBuffer Corresponds to DXC_OUT_ERRORS.<br/>
		/// </summary>
		public static HResult GetErrorBuffer(this ComPtr<IDxcOperationResult> comObj, ref IDxcBlobEncoding* ppErrors) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			fixed (IDxcBlobEncoding** pppErrors = &ppErrors)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, (IDxcBlobEncoding**)pppErrors);
				return ret;
			}
		}

		/// <summary>
		/// GetErrorBuffer Corresponds to DXC_OUT_ERRORS.<br/>
		/// </summary>
		public static HResult GetErrorBuffer(this ComPtr<IDxcOperationResult> comObj, out ComPtr<IDxcBlobEncoding> ppErrors) 
		{
			IDxcOperationResult* handle = comObj.Handle;
			ppErrors = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcOperationResult*, IDxcBlobEncoding**, HResult>)(handle->LpVtbl[5]))(handle, (IDxcBlobEncoding**)ppErrors.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcCompiler> comObj, Guid* riid, void** ppvObject) 
		{
			IDxcCompiler* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, riid, ppvObject);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface(this ComPtr<IDxcCompiler> comObj, ref Guid riid, void** ppvObject) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, ppvObject);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcCompiler> comObj, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcCompiler* handle = comObj.Handle;
			ppvObject = default;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvObject.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult QueryInterface<T>(this ComPtr<IDxcCompiler> comObj, ref Guid riid, out ComPtr<T> ppvObject) where T : unmanaged, IComObject, IComObject<T>
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (Guid* priid = &riid)
			{
				ppvObject = default;
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, Guid*, void**, HResult>)(*handle->LpVtbl))(handle, (Guid*)priid, (void**)ppvObject.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddRef(this ComPtr<IDxcCompiler> comObj) 
		{
			IDxcCompiler* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, uint>)(handle->LpVtbl[1]))(handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Release(this ComPtr<IDxcCompiler> comObj) 
		{
			IDxcCompiler* handle = comObj.Handle;
			uint ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, uint>)(handle->LpVtbl[2]))(handle);
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ComPtr<IDxcBlob> pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)pSource.Handle, pSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppEntryPoint = pEntryPoint)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pStr0, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntryPoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pStr0, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntryPoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pStr1, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppEntryPoint = pEntryPoint)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntryPoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pStr1, pTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppTargetProfile = pTargetProfile)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pTargetProfile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pTargetProfile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, pStr0, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pTargetProfile != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pTargetProfile, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, pStr0, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pTargetProfile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pEntryPoint, pStr1, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pTargetProfile != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pEntryPoint, pStr1, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppEntryPoint = pEntryPoint)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pTargetProfile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pStr0, pStr1, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntryPoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pTargetProfile != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pStr0, pStr1, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntryPoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			char* pStr2 = null;
			int pStrSize2 = 0;
			if (pTargetProfile != null)
			{
				pStrSize2 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<char>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = (char*)pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF16(pTargetProfile, pStr2, pStrSize2);
				pStr2[pStrOffset2] = '\0';
			}
			HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pStr1, pStr2, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppEntryPoint = pEntryPoint)
					{
						fixed (char* ppTargetProfile = pTargetProfile)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntryPoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				char* pStr2 = null;
				int pStrSize2 = 0;
				if (pTargetProfile != null)
				{
					pStrSize2 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<char>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = (char*)pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF16(pTargetProfile, pStr2, pStrSize2);
					pStr2[pStrOffset2] = '\0';
				}
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pStr1, pStr2, pArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ComPtr<IDxcBlob> pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)pSource.Handle, pSourceName, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char** ppArguments = &pArguments)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, char* pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppEntryPoint = pEntryPoint)
			{
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, (char*)ppEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, string pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pStr0, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char** ppArguments = &pArguments)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, (char*)ppEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, string pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntryPoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pStr0, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char** ppArguments = &pArguments)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, (char*)ppEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, string pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntryPoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pStr1, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppEntryPoint = pEntryPoint)
					{
						fixed (char** ppArguments = &pArguments)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, (char*)ppEntryPoint, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, string pEntryPoint, char* pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntryPoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pStr1, pTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppTargetProfile = pTargetProfile)
			{
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pTargetProfile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pTargetProfile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, pStr0, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					fixed (char** ppArguments = &pArguments)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pTargetProfile != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pTargetProfile, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, pStr0, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					fixed (char** ppArguments = &pArguments)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, pEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, char* pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pTargetProfile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pEntryPoint, pStr1, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						fixed (char** ppArguments = &pArguments)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, pEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, char* pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pTargetProfile != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pEntryPoint, pStr1, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppEntryPoint = pEntryPoint)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					fixed (char** ppArguments = &pArguments)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, string pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pTargetProfile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pStr0, pStr1, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						fixed (char** ppArguments = &pArguments)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, string pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntryPoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pTargetProfile != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pStr0, pStr1, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						fixed (char** ppArguments = &pArguments)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, string pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntryPoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			char* pStr2 = null;
			int pStrSize2 = 0;
			if (pTargetProfile != null)
			{
				pStrSize2 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<char>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = (char*)pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF16(pTargetProfile, pStr2, pStrSize2);
				pStr2[pStrOffset2] = '\0';
			}
			fixed (char** ppArguments = &pArguments)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pStr1, pStr2, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppEntryPoint = pEntryPoint)
					{
						fixed (char* ppTargetProfile = pTargetProfile)
						{
							fixed (char** ppArguments = &pArguments)
							{
								HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, string pEntryPoint, string pTargetProfile, ref char* pArguments, uint argCount, Define* pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntryPoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				char* pStr2 = null;
				int pStrSize2 = 0;
				if (pTargetProfile != null)
				{
					pStrSize2 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<char>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = (char*)pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF16(pTargetProfile, pStr2, pStrSize2);
					pStr2[pStrOffset2] = '\0';
				}
				fixed (char** ppArguments = &pArguments)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pStr1, pStr2, (char**)ppArguments, argCount, pDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ComPtr<IDxcBlob> pSource, char* pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)pSource.Handle, pSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (Define* ppDefines = &pDefines)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, char* pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppEntryPoint = pEntryPoint)
			{
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pStr0, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (Define* ppDefines = &pDefines)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntryPoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pStr0, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (Define* ppDefines = &pDefines)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntryPoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pStr1, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppEntryPoint = pEntryPoint)
					{
						fixed (Define* ppDefines = &pDefines)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, (char*)ppEntryPoint, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, string pEntryPoint, char* pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntryPoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pStr1, pTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppTargetProfile = pTargetProfile)
			{
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pTargetProfile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pTargetProfile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pEntryPoint, pStr0, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					fixed (Define* ppDefines = &pDefines)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pTargetProfile != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pTargetProfile, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pEntryPoint, pStr0, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					fixed (Define* ppDefines = &pDefines)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pTargetProfile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pEntryPoint, pStr1, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, char* pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						fixed (Define* ppDefines = &pDefines)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, pEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, char* pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pTargetProfile != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pEntryPoint, pStr1, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppEntryPoint = pEntryPoint)
			{
				fixed (char* ppTargetProfile = pTargetProfile)
				{
					fixed (Define* ppDefines = &pDefines)
					{
						HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, char* pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pTargetProfile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pSourceName, pStr0, pStr1, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						fixed (Define* ppDefines = &pDefines)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, char* pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntryPoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pEntryPoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pTargetProfile != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pTargetProfile, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pSourceName, pStr0, pStr1, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (char* ppSourceName = pSourceName)
			{
				fixed (char* ppEntryPoint = pEntryPoint)
				{
					fixed (char* ppTargetProfile = pTargetProfile)
					{
						fixed (Define* ppDefines = &pDefines)
						{
							HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, (char*)ppSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, IDxcBlob* pSource, string pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntryPoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			char* pStr2 = null;
			int pStrSize2 = 0;
			if (pTargetProfile != null)
			{
				pStrSize2 = Utils.GetByteCountUTF16(pTargetProfile);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<char>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = (char*)pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF16(pTargetProfile, pStr2, pStrSize2);
				pStr2[pStrOffset2] = '\0';
			}
			fixed (Define* ppDefines = &pDefines)
			{
				HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, pSource, pStr0, pStr1, pStr2, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, ReadOnlySpan<char> pSourceName, ReadOnlySpan<char> pEntryPoint, ReadOnlySpan<char> pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				fixed (char* ppSourceName = pSourceName)
				{
					fixed (char* ppEntryPoint = pEntryPoint)
					{
						fixed (char* ppTargetProfile = pTargetProfile)
						{
							fixed (Define* ppDefines = &pDefines)
							{
								HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, (char*)ppSourceName, (char*)ppEntryPoint, (char*)ppTargetProfile, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Compile a single entry point to the target shader model<br/>
		/// </summary>
		public static HResult Compile(this ComPtr<IDxcCompiler> comObj, ref IDxcBlob pSource, string pSourceName, string pEntryPoint, string pTargetProfile, char** pArguments, uint argCount, ref Define pDefines, uint defineCount, IDxcIncludeHandler* pIncludeHandler, IDxcOperationResult** ppResult) 
		{
			IDxcCompiler* handle = comObj.Handle;
			fixed (IDxcBlob* ppSource = &pSource)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pSourceName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pSourceName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pSourceName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				char* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntryPoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF16(pEntryPoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = (char*)pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF16(pEntryPoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = '\0';
				}
				char* pStr2 = null;
				int pStrSize2 = 0;
				if (pTargetProfile != null)
				{
					pStrSize2 = Utils.GetByteCountUTF16(pTargetProfile);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<char>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = (char*)pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF16(pTargetProfile, pStr2, pStrSize2);
					pStr2[pStrOffset2] = '\0';
				}
				fixed (Define* ppDefines = &pDefines)
				{
					HResult ret = ((delegate* unmanaged[Stdcall]<IDxcCompiler*, IDxcBlob*, char*, char*, char*, char**, uint, Define*, uint, IDxcIncludeHandler*, IDxcOperationResult**, HResult>)(handle->LpVtbl[3]))(handle, (IDxcBlob*)ppSource, pStr0, pStr1, pStr2, pArguments, argCount, (Define*)ppDefines, defineCount, pIncludeHandler, ppResult);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
	}
}

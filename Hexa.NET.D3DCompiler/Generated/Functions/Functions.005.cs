// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.D3DCommon;
using Hexa.NET.D3D11;
using HexaGen.Runtime.COM;

namespace Hexa.NET.D3DCompiler
{
	public unsafe partial class D3DCompiler
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompileFromFile(char* pFileName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							fixed (ID3D10Blob** pppCode = &ppCode)
							{
								fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
								{
									HResult ret = CompileFromFileNative(pFileName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, (ID3D10Blob**)pppErrorMsgs);
									return ret;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompileFromFile(char* pFileName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pEntrypoint != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pTarget != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = CompileFromFileNative(pFileName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr0, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, (ID3D10Blob**)pppErrorMsgs);
							if (pStrSize1 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr1);
							}
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompileFromFile(ReadOnlySpan<char> pFileName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (char* ppFileName = pFileName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppEntrypoint = pEntrypoint)
						{
							fixed (byte* ppTarget = pTarget)
							{
								fixed (ID3D10Blob** pppCode = &ppCode)
								{
									fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
									{
										HResult ret = CompileFromFileNative((char*)ppFileName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, (ID3D10Blob**)pppErrorMsgs);
										return ret;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompileFromFile(string pFileName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pEntrypoint != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (pTarget != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = CompileFromFileNative(pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr1, pStr2, flags1, flags2, (ID3D10Blob**)pppCode, (ID3D10Blob**)pppErrorMsgs);
							if (pStrSize2 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr2);
							}
							if (pStrSize1 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr1);
							}
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult PreprocessNative(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, byte*, ShaderMacro*, ID3DInclude*, ID3D10Blob**, ID3D10Blob**, HResult>)funcTable[5])(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, ppCodeText, ppErrorMsgs);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, nint, nint, nint, HResult>)funcTable[5])((nint)pSrcData, srcDataSize, (nint)pSourceName, (nint)pDefines, (nint)pInclude, (nint)ppCodeText, (nint)ppErrorMsgs);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, ppCodeText, ppErrorMsgs);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, ppCodeText, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, ppCodeText, ppErrorMsgs);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, ppCodeText, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, ppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, ppCodeText, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, ppCodeText, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, ppCodeText, ppErrorMsgs);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, ppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, ppCodeText, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, ppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, ppCodeText, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, ppCodeText, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, ppCodeText, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppCodeText = &ppCodeText)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppCodeText = &ppCodeText)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppCodeText = &ppCodeText)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (ID3D10Blob** pppCodeText = &ppCodeText)
						{
							HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, ppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ID3D10Blob** ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, ppCodeText, (ID3D10Blob**)pppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppCodeText = &ppCodeText)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppCodeText = &ppCodeText)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppCodeText = &ppCodeText)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCodeText = &ppCodeText)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = PreprocessNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (ID3D10Blob** pppCodeText = &ppCodeText)
						{
							fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
							{
								HResult ret = PreprocessNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DPreprocess:<br/>
		/// -------------<br/>
		/// Process source text with the compiler's preprocessor and return<br/>
		/// the resulting text.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Preprocess(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ref ID3D10Blob* ppCodeText, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCodeText = &ppCodeText)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = PreprocessNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (ID3D10Blob**)pppCodeText, (ID3D10Blob**)pppErrorMsgs);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetDebugInfo:<br/>
		/// -----------------------<br/>
		/// Gets shader debug info.  Debug info is generated by D3DCompile and is<br/>
		/// embedded in the body of the shader.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult GetDebugInfoNative(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppDebugInfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, ID3D10Blob**, HResult>)funcTable[6])(pSrcData, srcDataSize, ppDebugInfo);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, HResult>)funcTable[6])((nint)pSrcData, srcDataSize, (nint)ppDebugInfo);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetDebugInfo:<br/>
		/// -----------------------<br/>
		/// Gets shader debug info.  Debug info is generated by D3DCompile and is<br/>
		/// embedded in the body of the shader.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetDebugInfo(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppDebugInfo)
		{
			HResult ret = GetDebugInfoNative(pSrcData, srcDataSize, ppDebugInfo);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetDebugInfo:<br/>
		/// -----------------------<br/>
		/// Gets shader debug info.  Debug info is generated by D3DCompile and is<br/>
		/// embedded in the body of the shader.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetDebugInfo(void* pSrcData, nuint srcDataSize, ref ID3D10Blob* ppDebugInfo)
		{
			fixed (ID3D10Blob** pppDebugInfo = &ppDebugInfo)
			{
				HResult ret = GetDebugInfoNative(pSrcData, srcDataSize, (ID3D10Blob**)pppDebugInfo);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflect:<br/>
		/// ----------<br/>
		/// Shader code contains metadata that can be inspected via the<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult ReflectNative(void* pSrcData, nuint srcDataSize, Guid* pInterface, void** ppReflector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, Guid*, void**, HResult>)funcTable[7])(pSrcData, srcDataSize, pInterface, ppReflector);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, HResult>)funcTable[7])((nint)pSrcData, srcDataSize, (nint)pInterface, (nint)ppReflector);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflect:<br/>
		/// ----------<br/>
		/// Shader code contains metadata that can be inspected via the<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Reflect(void* pSrcData, nuint srcDataSize, Guid* pInterface, void** ppReflector)
		{
			HResult ret = ReflectNative(pSrcData, srcDataSize, pInterface, ppReflector);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflect:<br/>
		/// ----------<br/>
		/// Shader code contains metadata that can be inspected via the<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Reflect(void* pSrcData, nuint srcDataSize, ref Guid pInterface, void** ppReflector)
		{
			fixed (Guid* ppInterface = &pInterface)
			{
				HResult ret = ReflectNative(pSrcData, srcDataSize, (Guid*)ppInterface, ppReflector);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflect:<br/>
		/// ----------<br/>
		/// Shader code contains metadata that can be inspected via the<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Reflect<T>(void* pSrcData, nuint srcDataSize, out ComPtr<T> ppReflector) where T : unmanaged, IComObject, IComObject<T>
		{
			ppReflector = default;
			HResult ret = ReflectNative(pSrcData, srcDataSize, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppReflector.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflect:<br/>
		/// ----------<br/>
		/// Shader code contains metadata that can be inspected via the<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Reflect<T>(void* pSrcData, nuint srcDataSize, ref Guid pInterface, out ComPtr<T> ppReflector) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* ppInterface = &pInterface)
			{
				ppReflector = default;
				HResult ret = ReflectNative(pSrcData, srcDataSize, (Guid*)ppInterface, (void**)ppReflector.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflectLibrary:<br/>
		/// ----------<br/>
		/// Library code contains metadata that can be inspected via the library<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult ReflectLibraryNative(void* pSrcData, nuint srcDataSize, Guid* riid, void** ppReflector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, Guid*, void**, HResult>)funcTable[8])(pSrcData, srcDataSize, riid, ppReflector);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, HResult>)funcTable[8])((nint)pSrcData, srcDataSize, (nint)riid, (nint)ppReflector);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflectLibrary:<br/>
		/// ----------<br/>
		/// Library code contains metadata that can be inspected via the library<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReflectLibrary(void* pSrcData, nuint srcDataSize, Guid* riid, void** ppReflector)
		{
			HResult ret = ReflectLibraryNative(pSrcData, srcDataSize, riid, ppReflector);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflectLibrary:<br/>
		/// ----------<br/>
		/// Library code contains metadata that can be inspected via the library<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReflectLibrary(void* pSrcData, nuint srcDataSize, ref Guid riid, void** ppReflector)
		{
			fixed (Guid* priid = &riid)
			{
				HResult ret = ReflectLibraryNative(pSrcData, srcDataSize, (Guid*)priid, ppReflector);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflectLibrary:<br/>
		/// ----------<br/>
		/// Library code contains metadata that can be inspected via the library<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReflectLibrary(void* pSrcData, nuint srcDataSize, Guid* riid, ref void* ppReflector)
		{
			fixed (void** pppReflector = &ppReflector)
			{
				HResult ret = ReflectLibraryNative(pSrcData, srcDataSize, riid, (void**)pppReflector);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReflectLibrary:<br/>
		/// ----------<br/>
		/// Library code contains metadata that can be inspected via the library<br/>
		/// reflection APIs.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReflectLibrary(void* pSrcData, nuint srcDataSize, ref Guid riid, ref void* ppReflector)
		{
			fixed (Guid* priid = &riid)
			{
				fixed (void** pppReflector = &ppReflector)
				{
					HResult ret = ReflectLibraryNative(pSrcData, srcDataSize, (Guid*)priid, (void**)pppReflector);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult DisassembleNative(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, ID3D10Blob** ppDisassembly)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, uint, byte*, ID3D10Blob**, HResult>)funcTable[9])(pSrcData, srcDataSize, flags, szComments, ppDisassembly);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, uint, nint, nint, HResult>)funcTable[9])((nint)pSrcData, srcDataSize, flags, (nint)szComments, (nint)ppDisassembly);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Disassemble(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, ID3D10Blob** ppDisassembly)
		{
			HResult ret = DisassembleNative(pSrcData, srcDataSize, flags, szComments, ppDisassembly);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Disassemble(void* pSrcData, nuint srcDataSize, uint flags, ReadOnlySpan<byte> szComments, ID3D10Blob** ppDisassembly)
		{
			fixed (byte* pszComments = szComments)
			{
				HResult ret = DisassembleNative(pSrcData, srcDataSize, flags, (byte*)pszComments, ppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Disassemble(void* pSrcData, nuint srcDataSize, uint flags, string szComments, ID3D10Blob** ppDisassembly)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szComments != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szComments);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szComments, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			HResult ret = DisassembleNative(pSrcData, srcDataSize, flags, pStr0, ppDisassembly);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Disassemble(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, ref ID3D10Blob* ppDisassembly)
		{
			fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
			{
				HResult ret = DisassembleNative(pSrcData, srcDataSize, flags, szComments, (ID3D10Blob**)pppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Disassemble(void* pSrcData, nuint srcDataSize, uint flags, ReadOnlySpan<byte> szComments, ref ID3D10Blob* ppDisassembly)
		{
			fixed (byte* pszComments = szComments)
			{
				fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
				{
					HResult ret = DisassembleNative(pSrcData, srcDataSize, flags, (byte*)pszComments, (ID3D10Blob**)pppDisassembly);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Disassemble(void* pSrcData, nuint srcDataSize, uint flags, string szComments, ref ID3D10Blob* ppDisassembly)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szComments != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szComments);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szComments, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
			{
				HResult ret = DisassembleNative(pSrcData, srcDataSize, flags, pStr0, (ID3D10Blob**)pppDisassembly);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult DisassembleRegionNative(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, uint, byte*, nuint, nuint, nuint*, ID3D10Blob**, HResult>)funcTable[10])(pSrcData, srcDataSize, flags, szComments, startByteOffset, numInsts, pFinishByteOffset, ppDisassembly);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, uint, nint, nuint, nuint, nint, nint, HResult>)funcTable[10])((nint)pSrcData, srcDataSize, flags, (nint)szComments, startByteOffset, numInsts, (nint)pFinishByteOffset, (nint)ppDisassembly);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, szComments, startByteOffset, numInsts, pFinishByteOffset, ppDisassembly);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, ReadOnlySpan<byte> szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			fixed (byte* pszComments = szComments)
			{
				HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, (byte*)pszComments, startByteOffset, numInsts, pFinishByteOffset, ppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, string szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szComments != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szComments);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szComments, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, pStr0, startByteOffset, numInsts, pFinishByteOffset, ppDisassembly);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, nuint startByteOffset, nuint numInsts, ref nuint pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			fixed (nuint* ppFinishByteOffset = &pFinishByteOffset)
			{
				HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, szComments, startByteOffset, numInsts, (nuint*)ppFinishByteOffset, ppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, ReadOnlySpan<byte> szComments, nuint startByteOffset, nuint numInsts, ref nuint pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			fixed (byte* pszComments = szComments)
			{
				fixed (nuint* ppFinishByteOffset = &pFinishByteOffset)
				{
					HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, (byte*)pszComments, startByteOffset, numInsts, (nuint*)ppFinishByteOffset, ppDisassembly);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, string szComments, nuint startByteOffset, nuint numInsts, ref nuint pFinishByteOffset, ID3D10Blob** ppDisassembly)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szComments != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szComments);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szComments, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppFinishByteOffset = &pFinishByteOffset)
			{
				HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, pStr0, startByteOffset, numInsts, (nuint*)ppFinishByteOffset, ppDisassembly);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ref ID3D10Blob* ppDisassembly)
		{
			fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
			{
				HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, szComments, startByteOffset, numInsts, pFinishByteOffset, (ID3D10Blob**)pppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, ReadOnlySpan<byte> szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ref ID3D10Blob* ppDisassembly)
		{
			fixed (byte* pszComments = szComments)
			{
				fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
				{
					HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, (byte*)pszComments, startByteOffset, numInsts, pFinishByteOffset, (ID3D10Blob**)pppDisassembly);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, string szComments, nuint startByteOffset, nuint numInsts, nuint* pFinishByteOffset, ref ID3D10Blob* ppDisassembly)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szComments != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szComments);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szComments, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
			{
				HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, pStr0, startByteOffset, numInsts, pFinishByteOffset, (ID3D10Blob**)pppDisassembly);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, byte* szComments, nuint startByteOffset, nuint numInsts, ref nuint pFinishByteOffset, ref ID3D10Blob* ppDisassembly)
		{
			fixed (nuint* ppFinishByteOffset = &pFinishByteOffset)
			{
				fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
				{
					HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, szComments, startByteOffset, numInsts, (nuint*)ppFinishByteOffset, (ID3D10Blob**)pppDisassembly);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, ReadOnlySpan<byte> szComments, nuint startByteOffset, nuint numInsts, ref nuint pFinishByteOffset, ref ID3D10Blob* ppDisassembly)
		{
			fixed (byte* pszComments = szComments)
			{
				fixed (nuint* ppFinishByteOffset = &pFinishByteOffset)
				{
					fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
					{
						HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, (byte*)pszComments, startByteOffset, numInsts, (nuint*)ppFinishByteOffset, (ID3D10Blob**)pppDisassembly);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult DisassembleRegion(void* pSrcData, nuint srcDataSize, uint flags, string szComments, nuint startByteOffset, nuint numInsts, ref nuint pFinishByteOffset, ref ID3D10Blob* ppDisassembly)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szComments != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szComments);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szComments, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppFinishByteOffset = &pFinishByteOffset)
			{
				fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
				{
					HResult ret = DisassembleRegionNative(pSrcData, srcDataSize, flags, pStr0, startByteOffset, numInsts, (nuint*)ppFinishByteOffset, (ID3D10Blob**)pppDisassembly);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// Shader linking and Function Linking Graph (FLG) APIs<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult CreateLinkerNative(ID3D11Linker** ppLinker)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ID3D11Linker**, HResult>)funcTable[11])(ppLinker);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, HResult>)funcTable[11])((nint)ppLinker);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// Shader linking and Function Linking Graph (FLG) APIs<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult CreateLinker(ID3D11Linker** ppLinker)
		{
			HResult ret = CreateLinkerNative(ppLinker);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// Shader linking and Function Linking Graph (FLG) APIs<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult CreateLinker(ref ID3D11Linker* ppLinker)
		{
			fixed (ID3D11Linker** pppLinker = &ppLinker)
			{
				HResult ret = CreateLinkerNative((ID3D11Linker**)pppLinker);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// Shader linking and Function Linking Graph (FLG) APIs<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult CreateLinker(out ComPtr<ID3D11Linker> ppLinker)
		{
			ppLinker = default;
			HResult ret = CreateLinkerNative((ID3D11Linker**)ppLinker.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult LoadModuleNative(void* pSrcData, nuint cbSrcDataSize, ID3D11Module** ppModule)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, ID3D11Module**, HResult>)funcTable[12])(pSrcData, cbSrcDataSize, ppModule);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, HResult>)funcTable[12])((nint)pSrcData, cbSrcDataSize, (nint)ppModule);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadModule(void* pSrcData, nuint cbSrcDataSize, ID3D11Module** ppModule)
		{
			HResult ret = LoadModuleNative(pSrcData, cbSrcDataSize, ppModule);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadModule(void* pSrcData, nuint cbSrcDataSize, ref ID3D11Module* ppModule)
		{
			fixed (ID3D11Module** pppModule = &ppModule)
			{
				HResult ret = LoadModuleNative(pSrcData, cbSrcDataSize, (ID3D11Module**)pppModule);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult LoadModule(void* pSrcData, nuint cbSrcDataSize, out ComPtr<ID3D11Module> ppModule)
		{
			ppModule = default;
			HResult ret = LoadModuleNative(pSrcData, cbSrcDataSize, (ID3D11Module**)ppModule.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult CreateFunctionLinkingGraphNative(uint uFlags, ID3D11FunctionLinkingGraph** ppFunctionLinkingGraph)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ID3D11FunctionLinkingGraph**, HResult>)funcTable[13])(uFlags, ppFunctionLinkingGraph);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<uint, nint, HResult>)funcTable[13])(uFlags, (nint)ppFunctionLinkingGraph);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateFunctionLinkingGraph(uint uFlags, ID3D11FunctionLinkingGraph** ppFunctionLinkingGraph)
		{
			HResult ret = CreateFunctionLinkingGraphNative(uFlags, ppFunctionLinkingGraph);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateFunctionLinkingGraph(uint uFlags, ref ID3D11FunctionLinkingGraph* ppFunctionLinkingGraph)
		{
			fixed (ID3D11FunctionLinkingGraph** pppFunctionLinkingGraph = &ppFunctionLinkingGraph)
			{
				HResult ret = CreateFunctionLinkingGraphNative(uFlags, (ID3D11FunctionLinkingGraph**)pppFunctionLinkingGraph);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CreateFunctionLinkingGraph(uint uFlags, out ComPtr<ID3D11FunctionLinkingGraph> ppFunctionLinkingGraph)
		{
			ppFunctionLinkingGraph = default;
			HResult ret = CreateFunctionLinkingGraphNative(uFlags, (ID3D11FunctionLinkingGraph**)ppFunctionLinkingGraph.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult GetTraceInstructionOffsetsNative(void* pSrcData, nuint srcDataSize, uint flags, nuint startInstIndex, nuint numInsts, nuint* pOffsets, nuint* pTotalInsts)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, uint, nuint, nuint, nuint*, nuint*, HResult>)funcTable[14])(pSrcData, srcDataSize, flags, startInstIndex, numInsts, pOffsets, pTotalInsts);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, uint, nuint, nuint, nint, nint, HResult>)funcTable[14])((nint)pSrcData, srcDataSize, flags, startInstIndex, numInsts, (nint)pOffsets, (nint)pTotalInsts);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetTraceInstructionOffsets(void* pSrcData, nuint srcDataSize, uint flags, nuint startInstIndex, nuint numInsts, nuint* pOffsets, nuint* pTotalInsts)
		{
			HResult ret = GetTraceInstructionOffsetsNative(pSrcData, srcDataSize, flags, startInstIndex, numInsts, pOffsets, pTotalInsts);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetTraceInstructionOffsets(void* pSrcData, nuint srcDataSize, uint flags, nuint startInstIndex, nuint numInsts, ref nuint pOffsets, nuint* pTotalInsts)
		{
			fixed (nuint* ppOffsets = &pOffsets)
			{
				HResult ret = GetTraceInstructionOffsetsNative(pSrcData, srcDataSize, flags, startInstIndex, numInsts, (nuint*)ppOffsets, pTotalInsts);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetTraceInstructionOffsets(void* pSrcData, nuint srcDataSize, uint flags, nuint startInstIndex, nuint numInsts, nuint* pOffsets, ref nuint pTotalInsts)
		{
			fixed (nuint* ppTotalInsts = &pTotalInsts)
			{
				HResult ret = GetTraceInstructionOffsetsNative(pSrcData, srcDataSize, flags, startInstIndex, numInsts, pOffsets, (nuint*)ppTotalInsts);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetTraceInstructionOffsets(void* pSrcData, nuint srcDataSize, uint flags, nuint startInstIndex, nuint numInsts, ref nuint pOffsets, ref nuint pTotalInsts)
		{
			fixed (nuint* ppOffsets = &pOffsets)
			{
				fixed (nuint* ppTotalInsts = &pTotalInsts)
				{
					HResult ret = GetTraceInstructionOffsetsNative(pSrcData, srcDataSize, flags, startInstIndex, numInsts, (nuint*)ppOffsets, (nuint*)ppTotalInsts);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetInputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the input signature from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult GetInputSignatureBlobNative(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppSignatureBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, ID3D10Blob**, HResult>)funcTable[15])(pSrcData, srcDataSize, ppSignatureBlob);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, HResult>)funcTable[15])((nint)pSrcData, srcDataSize, (nint)ppSignatureBlob);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetInputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the input signature from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetInputSignatureBlob(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppSignatureBlob)
		{
			HResult ret = GetInputSignatureBlobNative(pSrcData, srcDataSize, ppSignatureBlob);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetInputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the input signature from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetInputSignatureBlob(void* pSrcData, nuint srcDataSize, ref ID3D10Blob* ppSignatureBlob)
		{
			fixed (ID3D10Blob** pppSignatureBlob = &ppSignatureBlob)
			{
				HResult ret = GetInputSignatureBlobNative(pSrcData, srcDataSize, (ID3D10Blob**)pppSignatureBlob);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetOutputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the output signature from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult GetOutputSignatureBlobNative(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppSignatureBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, ID3D10Blob**, HResult>)funcTable[16])(pSrcData, srcDataSize, ppSignatureBlob);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, HResult>)funcTable[16])((nint)pSrcData, srcDataSize, (nint)ppSignatureBlob);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetOutputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the output signature from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetOutputSignatureBlob(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppSignatureBlob)
		{
			HResult ret = GetOutputSignatureBlobNative(pSrcData, srcDataSize, ppSignatureBlob);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetOutputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the output signature from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetOutputSignatureBlob(void* pSrcData, nuint srcDataSize, ref ID3D10Blob* ppSignatureBlob)
		{
			fixed (ID3D10Blob** pppSignatureBlob = &ppSignatureBlob)
			{
				HResult ret = GetOutputSignatureBlobNative(pSrcData, srcDataSize, (ID3D10Blob**)pppSignatureBlob);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetInputAndOutputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the input and output signatures from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult GetInputAndOutputSignatureBlobNative(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppSignatureBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, ID3D10Blob**, HResult>)funcTable[17])(pSrcData, srcDataSize, ppSignatureBlob);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, HResult>)funcTable[17])((nint)pSrcData, srcDataSize, (nint)ppSignatureBlob);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetInputAndOutputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the input and output signatures from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetInputAndOutputSignatureBlob(void* pSrcData, nuint srcDataSize, ID3D10Blob** ppSignatureBlob)
		{
			HResult ret = GetInputAndOutputSignatureBlobNative(pSrcData, srcDataSize, ppSignatureBlob);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DGetInputAndOutputSignatureBlob:<br/>
		/// -----------------------<br/>
		/// Retrieve the input and output signatures from a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult GetInputAndOutputSignatureBlob(void* pSrcData, nuint srcDataSize, ref ID3D10Blob* ppSignatureBlob)
		{
			fixed (ID3D10Blob** pppSignatureBlob = &ppSignatureBlob)
			{
				HResult ret = GetInputAndOutputSignatureBlobNative(pSrcData, srcDataSize, (ID3D10Blob**)pppSignatureBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult StripShaderNative(void* pShaderBytecode, nuint bytecodeLength, uint uStripFlags, ID3D10Blob** ppStrippedBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, uint, ID3D10Blob**, HResult>)funcTable[18])(pShaderBytecode, bytecodeLength, uStripFlags, ppStrippedBlob);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, uint, nint, HResult>)funcTable[18])((nint)pShaderBytecode, bytecodeLength, uStripFlags, (nint)ppStrippedBlob);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult StripShader(void* pShaderBytecode, nuint bytecodeLength, uint uStripFlags, ID3D10Blob** ppStrippedBlob)
		{
			HResult ret = StripShaderNative(pShaderBytecode, bytecodeLength, uStripFlags, ppStrippedBlob);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult StripShader(void* pShaderBytecode, nuint bytecodeLength, uint uStripFlags, ref ID3D10Blob* ppStrippedBlob)
		{
			fixed (ID3D10Blob** pppStrippedBlob = &ppStrippedBlob)
			{
				HResult ret = StripShaderNative(pShaderBytecode, bytecodeLength, uStripFlags, (ID3D10Blob**)pppStrippedBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult GetBlobPartNative(void* pSrcData, nuint srcDataSize, BlobPart part, uint flags, ID3D10Blob** ppPart)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, BlobPart, uint, ID3D10Blob**, HResult>)funcTable[19])(pSrcData, srcDataSize, part, flags, ppPart);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, BlobPart, uint, nint, HResult>)funcTable[19])((nint)pSrcData, srcDataSize, part, flags, (nint)ppPart);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobPart(void* pSrcData, nuint srcDataSize, BlobPart part, uint flags, ID3D10Blob** ppPart)
		{
			HResult ret = GetBlobPartNative(pSrcData, srcDataSize, part, flags, ppPart);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult GetBlobPart(void* pSrcData, nuint srcDataSize, BlobPart part, uint flags, ref ID3D10Blob* ppPart)
		{
			fixed (ID3D10Blob** pppPart = &ppPart)
			{
				HResult ret = GetBlobPartNative(pSrcData, srcDataSize, part, flags, (ID3D10Blob**)pppPart);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DSetBlobPart:<br/>
		/// -----------------------<br/>
		/// Update information in a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult SetBlobPartNative(void* pSrcData, nuint srcDataSize, BlobPart part, uint flags, void* pPart, nuint partSize, ID3D10Blob** ppNewShader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, BlobPart, uint, void*, nuint, ID3D10Blob**, HResult>)funcTable[20])(pSrcData, srcDataSize, part, flags, pPart, partSize, ppNewShader);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, BlobPart, uint, nint, nuint, nint, HResult>)funcTable[20])((nint)pSrcData, srcDataSize, part, flags, (nint)pPart, partSize, (nint)ppNewShader);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DSetBlobPart:<br/>
		/// -----------------------<br/>
		/// Update information in a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult SetBlobPart(void* pSrcData, nuint srcDataSize, BlobPart part, uint flags, void* pPart, nuint partSize, ID3D10Blob** ppNewShader)
		{
			HResult ret = SetBlobPartNative(pSrcData, srcDataSize, part, flags, pPart, partSize, ppNewShader);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DSetBlobPart:<br/>
		/// -----------------------<br/>
		/// Update information in a compilation result.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult SetBlobPart(void* pSrcData, nuint srcDataSize, BlobPart part, uint flags, void* pPart, nuint partSize, ref ID3D10Blob* ppNewShader)
		{
			fixed (ID3D10Blob** pppNewShader = &ppNewShader)
			{
				HResult ret = SetBlobPartNative(pSrcData, srcDataSize, part, flags, pPart, partSize, (ID3D10Blob**)pppNewShader);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DCreateBlob:<br/>
		/// -----------------------<br/>
		/// Create an ID3DBlob instance.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult CreateBlobNative(nuint size, ID3D10Blob** ppBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, ID3D10Blob**, HResult>)funcTable[21])(size, ppBlob);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nuint, nint, HResult>)funcTable[21])(size, (nint)ppBlob);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DCreateBlob:<br/>
		/// -----------------------<br/>
		/// Create an ID3DBlob instance.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult CreateBlob(nuint size, ID3D10Blob** ppBlob)
		{
			HResult ret = CreateBlobNative(size, ppBlob);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DCreateBlob:<br/>
		/// -----------------------<br/>
		/// Create an ID3DBlob instance.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult CreateBlob(nuint size, ref ID3D10Blob* ppBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				HResult ret = CreateBlobNative(size, (ID3D10Blob**)pppBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult CompressShadersNative(uint uNumShaders, ShaderData* pShaderData, uint uFlags, ID3D10Blob** ppCompressedData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ShaderData*, uint, ID3D10Blob**, HResult>)funcTable[22])(uNumShaders, pShaderData, uFlags, ppCompressedData);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<uint, nint, uint, nint, HResult>)funcTable[22])(uNumShaders, (nint)pShaderData, uFlags, (nint)ppCompressedData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompressShaders(uint uNumShaders, ShaderData* pShaderData, uint uFlags, ID3D10Blob** ppCompressedData)
		{
			HResult ret = CompressShadersNative(uNumShaders, pShaderData, uFlags, ppCompressedData);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompressShaders(uint uNumShaders, ref ShaderData pShaderData, uint uFlags, ID3D10Blob** ppCompressedData)
		{
			fixed (ShaderData* ppShaderData = &pShaderData)
			{
				HResult ret = CompressShadersNative(uNumShaders, (ShaderData*)ppShaderData, uFlags, ppCompressedData);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompressShaders(uint uNumShaders, ShaderData* pShaderData, uint uFlags, ref ID3D10Blob* ppCompressedData)
		{
			fixed (ID3D10Blob** pppCompressedData = &ppCompressedData)
			{
				HResult ret = CompressShadersNative(uNumShaders, pShaderData, uFlags, (ID3D10Blob**)pppCompressedData);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult CompressShaders(uint uNumShaders, ref ShaderData pShaderData, uint uFlags, ref ID3D10Blob* ppCompressedData)
		{
			fixed (ShaderData* ppShaderData = &pShaderData)
			{
				fixed (ID3D10Blob** pppCompressedData = &ppCompressedData)
				{
					HResult ret = CompressShadersNative(uNumShaders, (ShaderData*)ppShaderData, uFlags, (ID3D10Blob**)pppCompressedData);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult DecompressShadersNative(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, uint* pIndices, uint uFlags, ID3D10Blob** ppShaders, uint* pTotalShaders)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, uint, uint, uint*, uint, ID3D10Blob**, uint*, HResult>)funcTable[23])(pSrcData, srcDataSize, uNumShaders, uStartIndex, pIndices, uFlags, ppShaders, pTotalShaders);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, uint, uint, nint, uint, nint, nint, HResult>)funcTable[23])((nint)pSrcData, srcDataSize, uNumShaders, uStartIndex, (nint)pIndices, uFlags, (nint)ppShaders, (nint)pTotalShaders);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, uint* pIndices, uint uFlags, ID3D10Blob** ppShaders, uint* pTotalShaders)
		{
			HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, pIndices, uFlags, ppShaders, pTotalShaders);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, ref uint pIndices, uint uFlags, ID3D10Blob** ppShaders, uint* pTotalShaders)
		{
			fixed (uint* ppIndices = &pIndices)
			{
				HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, (uint*)ppIndices, uFlags, ppShaders, pTotalShaders);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, uint* pIndices, uint uFlags, ref ID3D10Blob* ppShaders, uint* pTotalShaders)
		{
			fixed (ID3D10Blob** pppShaders = &ppShaders)
			{
				HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, pIndices, uFlags, (ID3D10Blob**)pppShaders, pTotalShaders);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, ref uint pIndices, uint uFlags, ref ID3D10Blob* ppShaders, uint* pTotalShaders)
		{
			fixed (uint* ppIndices = &pIndices)
			{
				fixed (ID3D10Blob** pppShaders = &ppShaders)
				{
					HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, (uint*)ppIndices, uFlags, (ID3D10Blob**)pppShaders, pTotalShaders);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, uint* pIndices, uint uFlags, ID3D10Blob** ppShaders, ref uint pTotalShaders)
		{
			fixed (uint* ppTotalShaders = &pTotalShaders)
			{
				HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, pIndices, uFlags, ppShaders, (uint*)ppTotalShaders);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, ref uint pIndices, uint uFlags, ID3D10Blob** ppShaders, ref uint pTotalShaders)
		{
			fixed (uint* ppIndices = &pIndices)
			{
				fixed (uint* ppTotalShaders = &pTotalShaders)
				{
					HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, (uint*)ppIndices, uFlags, ppShaders, (uint*)ppTotalShaders);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, uint* pIndices, uint uFlags, ref ID3D10Blob* ppShaders, ref uint pTotalShaders)
		{
			fixed (ID3D10Blob** pppShaders = &ppShaders)
			{
				fixed (uint* ppTotalShaders = &pTotalShaders)
				{
					HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, pIndices, uFlags, (ID3D10Blob**)pppShaders, (uint*)ppTotalShaders);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDecompressShaders:<br/>
		/// -----------------------<br/>
		/// Decompresses one or more shaders from a compressed set.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult DecompressShaders(void* pSrcData, nuint srcDataSize, uint uNumShaders, uint uStartIndex, ref uint pIndices, uint uFlags, ref ID3D10Blob* ppShaders, ref uint pTotalShaders)
		{
			fixed (uint* ppIndices = &pIndices)
			{
				fixed (ID3D10Blob** pppShaders = &ppShaders)
				{
					fixed (uint* ppTotalShaders = &pTotalShaders)
					{
						HResult ret = DecompressShadersNative(pSrcData, srcDataSize, uNumShaders, uStartIndex, (uint*)ppIndices, uFlags, (ID3D10Blob**)pppShaders, (uint*)ppTotalShaders);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDisassemble10Effect:<br/>
		/// -----------------------<br/>
		/// Takes a D3D10 effect interface and returns a<br/>
		/// buffer containing text assembly.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult Disassemble10EffectNative(ID3D10Effect* pEffect, uint flags, ID3D10Blob** ppDisassembly)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ID3D10Effect*, uint, ID3D10Blob**, HResult>)funcTable[24])(pEffect, flags, ppDisassembly);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, uint, nint, HResult>)funcTable[24])((nint)pEffect, flags, (nint)ppDisassembly);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDisassemble10Effect:<br/>
		/// -----------------------<br/>
		/// Takes a D3D10 effect interface and returns a<br/>
		/// buffer containing text assembly.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Disassemble10Effect(ID3D10Effect* pEffect, uint flags, ID3D10Blob** ppDisassembly)
		{
			HResult ret = Disassemble10EffectNative(pEffect, flags, ppDisassembly);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDisassemble10Effect:<br/>
		/// -----------------------<br/>
		/// Takes a D3D10 effect interface and returns a<br/>
		/// buffer containing text assembly.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Disassemble10Effect(ref ID3D10Effect pEffect, uint flags, ID3D10Blob** ppDisassembly)
		{
			fixed (ID3D10Effect* ppEffect = &pEffect)
			{
				HResult ret = Disassemble10EffectNative((ID3D10Effect*)ppEffect, flags, ppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDisassemble10Effect:<br/>
		/// -----------------------<br/>
		/// Takes a D3D10 effect interface and returns a<br/>
		/// buffer containing text assembly.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Disassemble10Effect(ID3D10Effect* pEffect, uint flags, ref ID3D10Blob* ppDisassembly)
		{
			fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
			{
				HResult ret = Disassemble10EffectNative(pEffect, flags, (ID3D10Blob**)pppDisassembly);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DDisassemble10Effect:<br/>
		/// -----------------------<br/>
		/// Takes a D3D10 effect interface and returns a<br/>
		/// buffer containing text assembly.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult Disassemble10Effect(ref ID3D10Effect pEffect, uint flags, ref ID3D10Blob* ppDisassembly)
		{
			fixed (ID3D10Effect* ppEffect = &pEffect)
			{
				fixed (ID3D10Blob** pppDisassembly = &ppDisassembly)
				{
					HResult ret = Disassemble10EffectNative((ID3D10Effect*)ppEffect, flags, (ID3D10Blob**)pppDisassembly);
					return ret;
				}
			}
		}

	}
}

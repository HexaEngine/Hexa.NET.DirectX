// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.D3DCommon;
using Hexa.NET.D3D11;
using HexaGen.Runtime.COM;

namespace Hexa.NET.D3DCompiler
{
	public unsafe partial class D3DCompiler
	{
		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult ReadFileToBlobNative(char* pFileName, ID3D10Blob** ppContents)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, ID3D10Blob**, HResult>)funcTable[0])(pFileName, ppContents);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nint, HResult>)funcTable[0])((nint)pFileName, (nint)ppContents);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReadFileToBlob(char* pFileName, ID3D10Blob** ppContents)
		{
			HResult ret = ReadFileToBlobNative(pFileName, ppContents);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReadFileToBlob(ReadOnlySpan<char> pFileName, ID3D10Blob** ppContents)
		{
			fixed (char* ppFileName = pFileName)
			{
				HResult ret = ReadFileToBlobNative((char*)ppFileName, ppContents);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReadFileToBlob(string pFileName, ID3D10Blob** ppContents)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = ReadFileToBlobNative(pStr0, ppContents);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReadFileToBlob(char* pFileName, ref ID3D10Blob* ppContents)
		{
			fixed (ID3D10Blob** pppContents = &ppContents)
			{
				HResult ret = ReadFileToBlobNative(pFileName, (ID3D10Blob**)pppContents);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReadFileToBlob(ReadOnlySpan<char> pFileName, ref ID3D10Blob* ppContents)
		{
			fixed (char* ppFileName = pFileName)
			{
				fixed (ID3D10Blob** pppContents = &ppContents)
				{
					HResult ret = ReadFileToBlobNative((char*)ppFileName, (ID3D10Blob**)pppContents);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DReadFileToBlob:<br/>
		/// -----------------<br/>
		/// Simple helper routine to read a file on disk into memory<br/>
		/// for passing to other routines in this API.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult ReadFileToBlob(string pFileName, ref ID3D10Blob* ppContents)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			fixed (ID3D10Blob** pppContents = &ppContents)
			{
				HResult ret = ReadFileToBlobNative(pStr0, (ID3D10Blob**)pppContents);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult WriteBlobToFileNative(ID3D10Blob* pBlob, char* pFileName, Bool32 bOverwrite)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ID3D10Blob*, char*, Bool32, HResult>)funcTable[1])(pBlob, pFileName, bOverwrite);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nint, Bool32, HResult>)funcTable[1])((nint)pBlob, (nint)pFileName, bOverwrite);
			#endif
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult WriteBlobToFile(ID3D10Blob* pBlob, char* pFileName, Bool32 bOverwrite)
		{
			HResult ret = WriteBlobToFileNative(pBlob, pFileName, bOverwrite);
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult WriteBlobToFile(ref ID3D10Blob pBlob, char* pFileName, Bool32 bOverwrite)
		{
			fixed (ID3D10Blob* ppBlob = &pBlob)
			{
				HResult ret = WriteBlobToFileNative((ID3D10Blob*)ppBlob, pFileName, bOverwrite);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult WriteBlobToFile(ID3D10Blob* pBlob, ReadOnlySpan<char> pFileName, Bool32 bOverwrite)
		{
			fixed (char* ppFileName = pFileName)
			{
				HResult ret = WriteBlobToFileNative(pBlob, (char*)ppFileName, bOverwrite);
				return ret;
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult WriteBlobToFile(ID3D10Blob* pBlob, string pFileName, Bool32 bOverwrite)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			HResult ret = WriteBlobToFileNative(pBlob, pStr0, bOverwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult WriteBlobToFile(ref ID3D10Blob pBlob, ReadOnlySpan<char> pFileName, Bool32 bOverwrite)
		{
			fixed (ID3D10Blob* ppBlob = &pBlob)
			{
				fixed (char* ppFileName = pFileName)
				{
					HResult ret = WriteBlobToFileNative((ID3D10Blob*)ppBlob, (char*)ppFileName, bOverwrite);
					return ret;
				}
			}
		}

		/// <summary>
		/// ----------------------------------------------------------------------------<br/>
		/// D3DWriteBlobToFile:<br/>
		/// ------------------<br/>
		/// Simple helper routine to write a memory blob to a file on disk.<br/>
		/// ----------------------------------------------------------------------------<br/>
		/// </summary>
		public static HResult WriteBlobToFile(ref ID3D10Blob pBlob, string pFileName, Bool32 bOverwrite)
		{
			fixed (ID3D10Blob* ppBlob = &pBlob)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (pFileName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(pFileName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(pFileName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				HResult ret = WriteBlobToFileNative((ID3D10Blob*)ppBlob, pStr0, bOverwrite);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static HResult CompileNative(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, byte*, ShaderMacro*, ID3DInclude*, byte*, byte*, uint, uint, ID3D10Blob**, ID3D10Blob**, HResult>)funcTable[2])(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
			#else
			return (HResult)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, nint, nint, nint, uint, uint, nint, nint, HResult>)funcTable[2])((nint)pSrcData, srcDataSize, (nint)pSourceName, (nint)pDefines, (nint)pInclude, (nint)pEntrypoint, (nint)pTarget, flags1, flags2, (nint)ppCode, (nint)ppErrorMsgs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppEntrypoint = pEntrypoint)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntrypoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pStr0, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntrypoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pStr1, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pStr0, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pStr1, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pStr0, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pStr1, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pEntrypoint != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr0, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppEntrypoint = pEntrypoint)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pEntrypoint != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr1, pTarget, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppTarget = pTarget)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pTarget != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, pStr0, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppTarget = pTarget)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pTarget != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pEntrypoint, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppTarget = pTarget)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pTarget != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pStr0, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppTarget = pTarget)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppTarget = pTarget)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pTarget != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr0, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppTarget = pTarget)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppTarget = pTarget)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pTarget != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr0, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppTarget = pTarget)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pTarget != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppEntrypoint = pEntrypoint)
			{
				fixed (byte* ppTarget = pTarget)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntrypoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pTarget != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pStr0, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (byte* ppTarget = pTarget)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntrypoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (pTarget != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pStr1, pStr2, flags1, flags2, ppCode, ppErrorMsgs);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (byte* ppTarget = pTarget)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pStr0, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (pTarget != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pStr1, pStr2, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (byte* ppTarget = pTarget)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pStr0, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (pTarget != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pStr1, pStr2, flags1, flags2, ppCode, ppErrorMsgs);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pEntrypoint != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pTarget != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr0, pStr1, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppEntrypoint = pEntrypoint)
						{
							fixed (byte* ppTarget = pTarget)
							{
								HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, ppCode, ppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pEntrypoint != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (pTarget != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr1, pStr2, flags1, flags2, ppCode, ppErrorMsgs);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppEntrypoint = pEntrypoint)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntrypoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pStr0, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntrypoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pStr1, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pStr0, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pStr1, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pStr0, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pStr1, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pEntrypoint != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr0, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppEntrypoint = pEntrypoint)
						{
							fixed (ID3D10Blob** pppCode = &ppCode)
							{
								HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pEntrypoint != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr1, pTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppTarget = pTarget)
			{
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pTarget != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, pStr0, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppTarget = pTarget)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pTarget != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pEntrypoint, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppTarget = pTarget)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pTarget != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pStr0, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppTarget = pTarget)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppTarget = pTarget)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pTarget != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr0, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppTarget = pTarget)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppTarget = pTarget)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pTarget != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pTarget, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr0, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppTarget = pTarget)
						{
							fixed (ID3D10Blob** pppCode = &ppCode)
							{
								HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pTarget != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppEntrypoint = pEntrypoint)
			{
				fixed (byte* ppTarget = pTarget)
				{
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntrypoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pTarget != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pStr0, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (byte* ppTarget = pTarget)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntrypoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (pTarget != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(pTarget);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			fixed (ID3D10Blob** pppCode = &ppCode)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pStr1, pStr2, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (byte* ppTarget = pTarget)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pStr0, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							fixed (ID3D10Blob** pppCode = &ppCode)
							{
								HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (pTarget != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pStr1, pStr2, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (byte* ppTarget = pTarget)
					{
						fixed (ID3D10Blob** pppCode = &ppCode)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pTarget != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pStr0, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							fixed (ID3D10Blob** pppCode = &ppCode)
							{
								HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (pTarget != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(pTarget);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				fixed (ID3D10Blob** pppCode = &ppCode)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pStr1, pStr2, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (byte* ppTarget = pTarget)
						{
							fixed (ID3D10Blob** pppCode = &ppCode)
							{
								HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (pEntrypoint != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pTarget != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pTarget, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr0, pStr1, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, ReadOnlySpan<byte> pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (byte* ppEntrypoint = pEntrypoint)
						{
							fixed (byte* ppTarget = pTarget)
							{
								fixed (ID3D10Blob** pppCode = &ppCode)
								{
									HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, (byte*)ppTarget, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
									return ret;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, string pEntrypoint, string pTarget, uint flags1, uint flags2, ref ID3D10Blob* ppCode, ID3D10Blob** ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (pEntrypoint != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (pTarget != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(pTarget);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(pTarget, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					fixed (ID3D10Blob** pppCode = &ppCode)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pStr1, pStr2, flags1, flags2, (ID3D10Blob**)pppCode, ppErrorMsgs);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr2);
						}
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ComPtr<ID3DInclude> pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)pInclude.Handle, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ComPtr<ID3DInclude> pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)pInclude.Handle, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (ID3DInclude* ppInclude = &pInclude)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, byte* pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, pEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppEntrypoint = pEntrypoint)
			{
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntrypoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, pInclude, pStr0, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pEntrypoint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
			{
				HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, pInclude, pStr1, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, pInclude, pStr0, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ShaderMacro* ppDefines = &pDefines)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, (ShaderMacro*)ppDefines, pInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ref ShaderMacro pDefines, ID3DInclude* pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, (ShaderMacro*)ppDefines, pInclude, pStr1, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				fixed (byte* ppEntrypoint = pEntrypoint)
				{
					fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
					{
						HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pEntrypoint != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pEntrypoint, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, pDefines, (ID3DInclude*)ppInclude, pStr0, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, ReadOnlySpan<byte> pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (byte* ppSourceName = pSourceName)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, (byte*)ppSourceName, pDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, string pSourceName, ShaderMacro* pDefines, ref ID3DInclude pInclude, string pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pSourceName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pSourceName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pSourceName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ID3DInclude* ppInclude = &pInclude)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pEntrypoint != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pEntrypoint);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pEntrypoint, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
				{
					HResult ret = CompileNative(pSrcData, srcDataSize, pStr0, pDefines, (ID3DInclude*)ppInclude, pStr1, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static HResult Compile(void* pSrcData, nuint srcDataSize, byte* pSourceName, ref ShaderMacro pDefines, ref ID3DInclude pInclude, ReadOnlySpan<byte> pEntrypoint, byte* pTarget, uint flags1, uint flags2, ID3D10Blob** ppCode, ref ID3D10Blob* ppErrorMsgs)
		{
			fixed (ShaderMacro* ppDefines = &pDefines)
			{
				fixed (ID3DInclude* ppInclude = &pInclude)
				{
					fixed (byte* ppEntrypoint = pEntrypoint)
					{
						fixed (ID3D10Blob** pppErrorMsgs = &ppErrorMsgs)
						{
							HResult ret = CompileNative(pSrcData, srcDataSize, pSourceName, (ShaderMacro*)ppDefines, (ID3DInclude*)ppInclude, (byte*)ppEntrypoint, pTarget, flags1, flags2, ppCode, (ID3D10Blob**)pppErrorMsgs);
							return ret;
						}
					}
				}
			}
		}
	}
}

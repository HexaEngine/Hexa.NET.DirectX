// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.DXGI;
using Hexa.NET.D3DCommon;
using HexaGen.Runtime.COM;

namespace Hexa.NET.D3D12
{
	public unsafe partial class D3D12
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SerializeRootSignatureNative(RootSignatureDesc* pRootSignature, RootSignatureVersion version, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<RootSignatureDesc*, RootSignatureVersion, ID3D10Blob**, ID3D10Blob**, int>)funcTable[0])(pRootSignature, version, ppBlob, ppErrorBlob);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, RootSignatureVersion, nint, nint, int>)funcTable[0])((nint)pRootSignature, version, (nint)ppBlob, (nint)ppErrorBlob);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(RootSignatureDesc* pRootSignature, RootSignatureVersion version, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			int ret = SerializeRootSignatureNative(pRootSignature, version, ppBlob, ppErrorBlob);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(ref RootSignatureDesc pRootSignature, RootSignatureVersion version, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				int ret = SerializeRootSignatureNative((RootSignatureDesc*)ppRootSignature, version, ppBlob, ppErrorBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(RootSignatureDesc* pRootSignature, RootSignatureVersion version, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				int ret = SerializeRootSignatureNative(pRootSignature, version, (ID3D10Blob**)pppBlob, ppErrorBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(ref RootSignatureDesc pRootSignature, RootSignatureVersion version, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					int ret = SerializeRootSignatureNative((RootSignatureDesc*)ppRootSignature, version, (ID3D10Blob**)pppBlob, ppErrorBlob);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(RootSignatureDesc* pRootSignature, RootSignatureVersion version, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
			{
				int ret = SerializeRootSignatureNative(pRootSignature, version, ppBlob, (ID3D10Blob**)pppErrorBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(ref RootSignatureDesc pRootSignature, RootSignatureVersion version, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					int ret = SerializeRootSignatureNative((RootSignatureDesc*)ppRootSignature, version, ppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(RootSignatureDesc* pRootSignature, RootSignatureVersion version, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					int ret = SerializeRootSignatureNative(pRootSignature, version, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeRootSignature(ref RootSignatureDesc pRootSignature, RootSignatureVersion version, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
					{
						int ret = SerializeRootSignatureNative((RootSignatureDesc*)ppRootSignature, version, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateRootSignatureDeserializerNative(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, Guid*, void**, int>)funcTable[1])(pSrcData, srcDataSizeInBytes, pRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, int>)funcTable[1])((nint)pSrcData, srcDataSizeInBytes, (nint)pRootSignatureDeserializerInterface, (nint)ppRootSignatureDeserializer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			int ret = CreateRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, pRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, ref Guid pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			fixed (Guid* ppRootSignatureDeserializerInterface = &pRootSignatureDeserializerInterface)
			{
				int ret = CreateRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)ppRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateRootSignatureDeserializer<T>(void* pSrcData, nuint srcDataSizeInBytes, out ComPtr<T> ppRootSignatureDeserializer) where T : unmanaged, IComObject, IComObject<T>
		{
			ppRootSignatureDeserializer = default;
			int ret = CreateRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppRootSignatureDeserializer.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateRootSignatureDeserializer<T>(void* pSrcData, nuint srcDataSizeInBytes, ref Guid pRootSignatureDeserializerInterface, out ComPtr<T> ppRootSignatureDeserializer) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* ppRootSignatureDeserializerInterface = &pRootSignatureDeserializerInterface)
			{
				ppRootSignatureDeserializer = default;
				int ret = CreateRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)ppRootSignatureDeserializerInterface, (void**)ppRootSignatureDeserializer.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SerializeVersionedRootSignatureNative(VersionedRootSignatureDesc* pRootSignature, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VersionedRootSignatureDesc*, ID3D10Blob**, ID3D10Blob**, int>)funcTable[2])(pRootSignature, ppBlob, ppErrorBlob);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[2])((nint)pRootSignature, (nint)ppBlob, (nint)ppErrorBlob);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(VersionedRootSignatureDesc* pRootSignature, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			int ret = SerializeVersionedRootSignatureNative(pRootSignature, ppBlob, ppErrorBlob);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(ref VersionedRootSignatureDesc pRootSignature, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				int ret = SerializeVersionedRootSignatureNative((VersionedRootSignatureDesc*)ppRootSignature, ppBlob, ppErrorBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(VersionedRootSignatureDesc* pRootSignature, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				int ret = SerializeVersionedRootSignatureNative(pRootSignature, (ID3D10Blob**)pppBlob, ppErrorBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(ref VersionedRootSignatureDesc pRootSignature, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					int ret = SerializeVersionedRootSignatureNative((VersionedRootSignatureDesc*)ppRootSignature, (ID3D10Blob**)pppBlob, ppErrorBlob);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(VersionedRootSignatureDesc* pRootSignature, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
			{
				int ret = SerializeVersionedRootSignatureNative(pRootSignature, ppBlob, (ID3D10Blob**)pppErrorBlob);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(ref VersionedRootSignatureDesc pRootSignature, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					int ret = SerializeVersionedRootSignatureNative((VersionedRootSignatureDesc*)ppRootSignature, ppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(VersionedRootSignatureDesc* pRootSignature, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					int ret = SerializeVersionedRootSignatureNative(pRootSignature, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SerializeVersionedRootSignature(ref VersionedRootSignatureDesc pRootSignature, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
					{
						int ret = SerializeVersionedRootSignatureNative((VersionedRootSignatureDesc*)ppRootSignature, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateVersionedRootSignatureDeserializerNative(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, Guid*, void**, int>)funcTable[3])(pSrcData, srcDataSizeInBytes, pRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, int>)funcTable[3])((nint)pSrcData, srcDataSizeInBytes, (nint)pRootSignatureDeserializerInterface, (nint)ppRootSignatureDeserializer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateVersionedRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			int ret = CreateVersionedRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, pRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateVersionedRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, ref Guid pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			fixed (Guid* ppRootSignatureDeserializerInterface = &pRootSignatureDeserializerInterface)
			{
				int ret = CreateVersionedRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)ppRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateVersionedRootSignatureDeserializer<T>(void* pSrcData, nuint srcDataSizeInBytes, out ComPtr<T> ppRootSignatureDeserializer) where T : unmanaged, IComObject, IComObject<T>
		{
			ppRootSignatureDeserializer = default;
			int ret = CreateVersionedRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppRootSignatureDeserializer.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateVersionedRootSignatureDeserializer<T>(void* pSrcData, nuint srcDataSizeInBytes, ref Guid pRootSignatureDeserializerInterface, out ComPtr<T> ppRootSignatureDeserializer) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* ppRootSignatureDeserializerInterface = &pRootSignatureDeserializerInterface)
			{
				ppRootSignatureDeserializer = default;
				int ret = CreateVersionedRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)ppRootSignatureDeserializerInterface, (void**)ppRootSignatureDeserializer.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateDeviceNative(IUnknown* pAdapter, FeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<IUnknown*, FeatureLevel, Guid*, void**, int>)funcTable[4])(pAdapter, minimumFeatureLevel, riid, ppDevice);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, FeatureLevel, nint, nint, int>)funcTable[4])((nint)pAdapter, minimumFeatureLevel, (nint)riid, (nint)ppDevice);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice(IUnknown* pAdapter, FeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice)
		{
			int ret = CreateDeviceNative(pAdapter, minimumFeatureLevel, riid, ppDevice);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice(ref IUnknown pAdapter, FeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice)
		{
			fixed (IUnknown* ppAdapter = &pAdapter)
			{
				int ret = CreateDeviceNative((IUnknown*)ppAdapter, minimumFeatureLevel, riid, ppDevice);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice(ComPtr<IUnknown> pAdapter, FeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice)
		{
			int ret = CreateDeviceNative((IUnknown*)pAdapter.Handle, minimumFeatureLevel, riid, ppDevice);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice(IUnknown* pAdapter, FeatureLevel minimumFeatureLevel, ref Guid riid, void** ppDevice)
		{
			fixed (Guid* priid = &riid)
			{
				int ret = CreateDeviceNative(pAdapter, minimumFeatureLevel, (Guid*)priid, ppDevice);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice(ref IUnknown pAdapter, FeatureLevel minimumFeatureLevel, ref Guid riid, void** ppDevice)
		{
			fixed (IUnknown* ppAdapter = &pAdapter)
			{
				fixed (Guid* priid = &riid)
				{
					int ret = CreateDeviceNative((IUnknown*)ppAdapter, minimumFeatureLevel, (Guid*)priid, ppDevice);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice(ComPtr<IUnknown> pAdapter, FeatureLevel minimumFeatureLevel, ref Guid riid, void** ppDevice)
		{
			fixed (Guid* priid = &riid)
			{
				int ret = CreateDeviceNative((IUnknown*)pAdapter.Handle, minimumFeatureLevel, (Guid*)priid, ppDevice);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice<T>(IUnknown* pAdapter, FeatureLevel minimumFeatureLevel, out ComPtr<T> ppDevice) where T : unmanaged, IComObject, IComObject<T>
		{
			ppDevice = default;
			int ret = CreateDeviceNative(pAdapter, minimumFeatureLevel, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppDevice.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice<T>(ComPtr<IUnknown> pAdapter, FeatureLevel minimumFeatureLevel, out ComPtr<T> ppDevice) where T : unmanaged, IComObject, IComObject<T>
		{
			ppDevice = default;
			int ret = CreateDeviceNative((IUnknown*)pAdapter.Handle, minimumFeatureLevel, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppDevice.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice<T>(IUnknown* pAdapter, FeatureLevel minimumFeatureLevel, ref Guid riid, out ComPtr<T> ppDevice) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* priid = &riid)
			{
				ppDevice = default;
				int ret = CreateDeviceNative(pAdapter, minimumFeatureLevel, (Guid*)priid, (void**)ppDevice.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CreateDevice<T>(ComPtr<IUnknown> pAdapter, FeatureLevel minimumFeatureLevel, ref Guid riid, out ComPtr<T> ppDevice) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* priid = &riid)
			{
				ppDevice = default;
				int ret = CreateDeviceNative((IUnknown*)pAdapter.Handle, minimumFeatureLevel, (Guid*)priid, (void**)ppDevice.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDebugInterfaceNative(Guid* riid, void** ppvDebug)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Guid*, void**, int>)funcTable[5])(riid, ppvDebug);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[5])((nint)riid, (nint)ppvDebug);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDebugInterface(Guid* riid, void** ppvDebug)
		{
			int ret = GetDebugInterfaceNative(riid, ppvDebug);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDebugInterface(ref Guid riid, void** ppvDebug)
		{
			fixed (Guid* priid = &riid)
			{
				int ret = GetDebugInterfaceNative((Guid*)priid, ppvDebug);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDebugInterface<T>(out ComPtr<T> ppvDebug) where T : unmanaged, IComObject, IComObject<T>
		{
			ppvDebug = default;
			int ret = GetDebugInterfaceNative((Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvDebug.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDebugInterface<T>(ref Guid riid, out ComPtr<T> ppvDebug) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* priid = &riid)
			{
				ppvDebug = default;
				int ret = GetDebugInterfaceNative((Guid*)priid, (void**)ppvDebug.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EnableExperimentalFeaturesNative(uint numFeatures, Guid* pIIDs, void* pConfigurationStructs, uint* pConfigurationStructSizes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, Guid*, void*, uint*, int>)funcTable[6])(numFeatures, pIIDs, pConfigurationStructs, pConfigurationStructSizes);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, int>)funcTable[6])(numFeatures, (nint)pIIDs, (nint)pConfigurationStructs, (nint)pConfigurationStructSizes);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures(uint numFeatures, Guid* pIIDs, void* pConfigurationStructs, uint* pConfigurationStructSizes)
		{
			int ret = EnableExperimentalFeaturesNative(numFeatures, pIIDs, pConfigurationStructs, pConfigurationStructSizes);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures(uint numFeatures, ref Guid pIIDs, void* pConfigurationStructs, uint* pConfigurationStructSizes)
		{
			fixed (Guid* ppIIDs = &pIIDs)
			{
				int ret = EnableExperimentalFeaturesNative(numFeatures, (Guid*)ppIIDs, pConfigurationStructs, pConfigurationStructSizes);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures<T>(uint numFeatures, ComPtr<T> pConfigurationStructs, uint* pConfigurationStructSizes) where T : unmanaged, IComObject, IComObject<T>
		{
			int ret = EnableExperimentalFeaturesNative(numFeatures, (Guid*)(ComUtils.GuidPtrOf<T>()), (void*)pConfigurationStructs.Handle, pConfigurationStructSizes);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures<T>(uint numFeatures, ref Guid pIIDs, ComPtr<T> pConfigurationStructs, uint* pConfigurationStructSizes) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* ppIIDs = &pIIDs)
			{
				int ret = EnableExperimentalFeaturesNative(numFeatures, (Guid*)ppIIDs, (void*)pConfigurationStructs.Handle, pConfigurationStructSizes);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures(uint numFeatures, Guid* pIIDs, void* pConfigurationStructs, ref uint pConfigurationStructSizes)
		{
			fixed (uint* ppConfigurationStructSizes = &pConfigurationStructSizes)
			{
				int ret = EnableExperimentalFeaturesNative(numFeatures, pIIDs, pConfigurationStructs, (uint*)ppConfigurationStructSizes);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures(uint numFeatures, ref Guid pIIDs, void* pConfigurationStructs, ref uint pConfigurationStructSizes)
		{
			fixed (Guid* ppIIDs = &pIIDs)
			{
				fixed (uint* ppConfigurationStructSizes = &pConfigurationStructSizes)
				{
					int ret = EnableExperimentalFeaturesNative(numFeatures, (Guid*)ppIIDs, pConfigurationStructs, (uint*)ppConfigurationStructSizes);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures<T>(uint numFeatures, ComPtr<T> pConfigurationStructs, ref uint pConfigurationStructSizes) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (uint* ppConfigurationStructSizes = &pConfigurationStructSizes)
			{
				int ret = EnableExperimentalFeaturesNative(numFeatures, (Guid*)(ComUtils.GuidPtrOf<T>()), (void*)pConfigurationStructs.Handle, (uint*)ppConfigurationStructSizes);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		public static int EnableExperimentalFeatures<T>(uint numFeatures, ref Guid pIIDs, ComPtr<T> pConfigurationStructs, ref uint pConfigurationStructSizes) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* ppIIDs = &pIIDs)
			{
				fixed (uint* ppConfigurationStructSizes = &pConfigurationStructSizes)
				{
					int ret = EnableExperimentalFeaturesNative(numFeatures, (Guid*)ppIIDs, (void*)pConfigurationStructs.Handle, (uint*)ppConfigurationStructSizes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetInterfaceNative(Guid* rclsid, Guid* riid, void** ppvDebug)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Guid*, Guid*, void**, int>)funcTable[7])(rclsid, riid, ppvDebug);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[7])((nint)rclsid, (nint)riid, (nint)ppvDebug);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface(Guid* rclsid, Guid* riid, void** ppvDebug)
		{
			int ret = GetInterfaceNative(rclsid, riid, ppvDebug);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface(ref Guid rclsid, Guid* riid, void** ppvDebug)
		{
			fixed (Guid* prclsid = &rclsid)
			{
				int ret = GetInterfaceNative((Guid*)prclsid, riid, ppvDebug);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface(Guid* rclsid, ref Guid riid, void** ppvDebug)
		{
			fixed (Guid* priid = &riid)
			{
				int ret = GetInterfaceNative(rclsid, (Guid*)priid, ppvDebug);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface(ref Guid rclsid, ref Guid riid, void** ppvDebug)
		{
			fixed (Guid* prclsid = &rclsid)
			{
				fixed (Guid* priid = &riid)
				{
					int ret = GetInterfaceNative((Guid*)prclsid, (Guid*)priid, ppvDebug);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface<T>(Guid* rclsid, out ComPtr<T> ppvDebug) where T : unmanaged, IComObject, IComObject<T>
		{
			ppvDebug = default;
			int ret = GetInterfaceNative(rclsid, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvDebug.GetAddressOf());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface<T>(ref Guid rclsid, out ComPtr<T> ppvDebug) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* prclsid = &rclsid)
			{
				ppvDebug = default;
				int ret = GetInterfaceNative((Guid*)prclsid, (Guid*)(ComUtils.GuidPtrOf<T>()), (void**)ppvDebug.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface<T>(Guid* rclsid, ref Guid riid, out ComPtr<T> ppvDebug) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* priid = &riid)
			{
				ppvDebug = default;
				int ret = GetInterfaceNative(rclsid, (Guid*)priid, (void**)ppvDebug.GetAddressOf());
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInterface<T>(ref Guid rclsid, ref Guid riid, out ComPtr<T> ppvDebug) where T : unmanaged, IComObject, IComObject<T>
		{
			fixed (Guid* prclsid = &rclsid)
			{
				fixed (Guid* priid = &riid)
				{
					ppvDebug = default;
					int ret = GetInterfaceNative((Guid*)prclsid, (Guid*)priid, (void**)ppvDebug.GetAddressOf());
					return ret;
				}
			}
		}

	}
}
